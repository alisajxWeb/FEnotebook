(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{355:function(t,v,_){"use strict";_.r(v);var a=_(43),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h3",{attrs:{id:"_1-定义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-定义"}},[t._v("#")]),t._v(" 1.定义")]),t._v(" "),_("p",[t._v("​\t模式：是一种可复用的解决方案，用于解决软件设计中的常见问题")]),t._v(" "),_("h5",{attrs:{id:"优势和特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优势和特点"}},[t._v("#")]),t._v(" 优势和特点")]),t._v(" "),_("p",[t._v("​\t可靠：已经验证；容易被复用；富有表达力：表达词汇准确")]),t._v(" "),_("p",[t._v("​\t所以：1.防止小问题变成大问题，2。提供通用的解决方案，3.减少整体资源占有量，4.沟通便捷，5.可更新社区使其健壮")]),t._v(" "),_("h5",{attrs:{id:"优秀的模式："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优秀的模式："}},[t._v("#")]),t._v(" 优秀的模式：")]),t._v(" "),_("p",[t._v("​\t· 解决特殊问题；获取的是一种解决方案而非原则或策略")]),t._v(" "),_("p",[t._v("​\t· 没有显而易见的解决方案：解决的问题没有其他简单的解决方案")]),t._v(" "),_("p",[t._v("​\t· 描述与作用一致")]),t._v(" "),_("p",[t._v("​\t· 描述一种关系：深入解释代码关系和系统结构，机制.")]),t._v(" "),_("p",[t._v("​\t· 特性：适合性，实用性，适用性")]),t._v(" "),_("h5",{attrs:{id:"设计模式结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式结构"}},[t._v("#")]),t._v(" 设计模式结构")]),t._v(" "),_("p",[t._v("​\t规则：上下文, 上下文里产生的元件元素， 解决元件在上下文中自身问题的配置")]),t._v(" "),_("p",[t._v("​\t内容：模式名称，描述，上下文大纲，问题陈述，解决方案，设计描述，实现指导，插图，示例，辅助条件，关系，已知\t用法，讨论")]),t._v(" "),_("h5",{attrs:{id:"反模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#反模式"}},[t._v("#")]),t._v(" 反模式")]),t._v(" "),_("p",[t._v("​\t1.描述一种针对某个特定问题的不良解决方案，该方案会导致糟糕的情况发生")]),t._v(" "),_("p",[t._v("​\t2.描述如何摆脱前述的糟糕情况以及如何创造好的解决方案")]),t._v(" "),_("p",[t._v("​\t理解反模式可以让我们探究原因，在维护设计模式给以依据指导，使最终解决方案完美")]),t._v(" "),_("p",[t._v("​\t列举js的反模式：")]),t._v(" "),_("p",[t._v("​\t\t1.在全局上下文中定义大量的变量，全局污染命名空间")]),t._v(" "),_("p",[t._v("​\t\t2.向setTimeout或setInterval传递字符串而不是函数，会出发eval()的使用")]),t._v(" "),_("p",[t._v("​\t\t3.修改object类的原型")]),t._v(" "),_("p",[t._v("​\t\t4.以内联形式使用js，是不可改变的")]),t._v(" "),_("p",[t._v("​\t\t5.在使用document.createElement等原生dom方法更合适的情况下使用了document.write，多年以来，这个方法都被滥用，并且有很多缺点：页面加载完毕后执行这个方法，实际上会重写我们所在的页面，但document.createElement不会。")]),t._v(" "),_("h5",{attrs:{id:"设计模式类别："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式类别："}},[t._v("#")]),t._v(" 设计模式类别：")]),t._v(" "),_("p",[t._v("​\t1.创建型设计模式：专注于处理对象创建机制，以适合的情况来创建对象")]),t._v(" "),_("p",[t._v("Constructor（构造器），Factory（工厂），Abstract（抽象），Prototype（原型），Singleton（单例），BUilder（生成器）")]),t._v(" "),_("p",[t._v("​\t2.结构型设计模式：与对象组合有关，找出不同对象之间建立关系的简单方法")]),t._v(" "),_("p",[t._v("Decorator（装饰者），Facade（外观），Flyweight（享元），Adapter（适配器），Proxy(代理)")]),t._v(" "),_("p",[t._v("​\t3.行为型设计模式：改善和简化不同对象之间的通信")]),t._v(" "),_("p",[t._v("Iterator（迭代器），Mediator（中介者），Observer（观察者）,Visitor（访问者）")])])}),[],!1,null,null,null);v.default=e.exports}}]);