#### 1.对象定义方式与描述符关系

​	读取属性的描述：Object.getOwnPropertyDescriptor()或getOwnPropertyDescriptor()

​	设置属性的描述：Object.definePropertype或Object.defineProperties

​	1）使用**Object.definePropertype**创建对象：省略的描述符默认值都是false,getter和setter都是undefined

​	2）直接在对象中创建时（字面量描述方式），所有描述符默认值都是true

#### 2.对象属性描述符

​	数据描述符：是一个有值的属性，可写，也可以不可写

​	存取描述符：由getter，setter函数对描述的属性

##### 	数据描述符：

​		**configurable**-：是否可以删除某个属性或修改属性的描述，为true时可进行操作，如果该属性先定义为false,后续又定义为true的话会报错

```javascript
		Object.defineProperty(person,'name',{
       configurable:false
     })
     Object.defineProperty(person,'name',{
      configurable:true
     })
```

​		**writable**-属性是否可写

```javascript
Object.defineProperty(person,'name', {
  writable:false
})
person.name='小李'; //属性不可写，严格模式下会报错console.log(person.name); //输出小王，说明上面一句无效`
```

​		**enumerable**-属性是否可被枚举，**默认为false**,该属性主要是用来防范Object.keys（）和for in的，也就是说该属性设置对于Object.getOwnPropertyNames()方法是无效的。

​			枚举属性输出的数组元素顺序：

​				在es5中并没有明确这一点，各个浏览器有自己的实现，es6中采用Object.keys（）和for in方法时还是没有明确；

​				采用Object.getOwnPropertyNames()方法枚举时，有了相应的标准：

最先放入数组中的是数值型的成员名，按升序排列；其次是其它类型的，按添加的先后顺序排列

​		**`value``-`**该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined

##### 	存取描述符：

​			**get与set**-读写成员时调用的函数，默认为undefined，如果只有get则表示属性值是只读的，只有set表示只能写。属性读写器最常用的场景就是在读取或写入属性前可以附带的做一些操作，达到更好的封装性。

```javascript
		Object.defineProperty(person,'pri',{
       get:function(){
         //做一些其它操作
         console.log('准备获取_pri的值')
         return _pri;
       },
       set:function(newValue){
         _pri =newValue
       }
     })
     person.pri='456';
     console.log(person.pri);
```

##### 某些描述符是相互排斥的，相应的关系见下表：

​		![img](https://img2018.cnblogs.com/blog/1155527/201908/1155527-20190810120358835-1368073487.png)

#### 3.对象保护

​	1）阻止在对象添加成员

​			**Object.preventExtensions()**该方法用于阻止向对象添加成员,

​			使用Object.isExtensible()判断对象是否可添加成员

```javascript
		Object.preventExtensions(person);
    //添加成员无效，非严格模式下什么都不会发生，严格模式下会报错
    person.bankAccount='中国农业银行'
    //依然可以删除成员，证明了preventExtensions方法只能阻止添加方法
    delete person.age;
    console.log(person.age) //undefined，表明删除成功了
```

​		2）阻止添加/删除成员

​			**Object.seal()**用来阻止添加或删除成员，

​			判断对象是否是密封的，可采用Object.isSealed()

​		3）阻止添加，删除，赋值修改：

​			**Object.freeze()**会阻止添加，删除，赋值修改，但仍然可以写入

![image-20200515103234996](/Users/alisa/mac/Documents/learn/FEnotebook/设计模式/image-20200515103234996.png)

#### 4.其他技巧：

​	1）实现继承：

​	Object.create(person)可产生一个具有继承特性的新对象，但父对象与子对象共享引用类型成员，即修改子对象引用类型成员时，父对象该成员也被同步变化

```javascript
let father = {
    name: '小王',
    age: 24,
    act: 'father',
  	friends: ['小红', '小李']
}
let child = Object.create(father)
child._proto_.act = 'son' // father的act也变成了son
child.friends.splice(0, 1) // father的friends也减少了一个
```

​	es6中的Object.setPrototypeOf(obj, prototype)方法可将已有的对象变成继承关系，其内部原理和Object.create一样，都是将子对象的prototype指向父对象，该方法实现的继承依然有抚子对象共享了引用类型成员的问题

​	

```javascript
  	var person={
       age:15
     }
     var man={
        
     }
    Object.setPrototypeOf(man,person)
    console.log(Object.getPrototypeOf(man)===person) //true
    console.log(man.age); //15
```

​	2）继承对象的属性赋值问题

​		**若父对象属性设置为不可写，向子对象该属性赋值，严格模式下报错，非严格模式下不生效**

```javascript
var parent={
  name:'parent'
}
Object.defineProperty(parent,'name',{
  writable:false
})
var child=Object.create(parent)
child.name='child' //严格模式下报错，非严格模式下默认失败
```

​		**若父对象的属性设置了set描述符，赋值这个继承的子对象对应属性时会触发set,如果未定义get，则无法获取属性值**

```javascript
'use strict'
var parent={
  name:'parent'
}
Object.defineProperty(parent,'name',{
  set(val){
    console.log('父元素的set被调用了')
    this._name = val
  }
})
var child=Object.create(parent)
child.name='child' //会触发父对象中的set
console.log(child.name) //undefined,只有父对象的name属性描述符设置了get才能获取到值
```

​	3）重写父对象成员

​		直接在子对象定义一个同名成员

​	4）实现在子对象中访问父对象成员

​		es6新增：super关键字，是一个指向当前对象原型的指针，即父对象

```javascript
let father = {
    name: '小王',
    age: 24,
    act: 'father',
    say: function () {console.log('我是父亲')}
}
let child = {
	say() {
		console.log('我是儿子，我父亲说：');
		super.say();
	}
}
Object.setPrototypeOf(child, father)
child.say() // 我是儿子，我父亲说： 我是父亲
```

​	如果不是继承关系，使用super会报错

​	5）一句话实现jquery.extend

​		jquery.extend是一个典型的对象混入

​		*对象混入：*将n个对象组合成一个新的对象，新对象具有各个输入对象的所有特征，在设计模式里也叫**装饰器模式**

​		示例：一个简易版的jq.extend的浅拷贝模式

```javascript
		function mixins(target,sourceArr){
       sourceArr.forEach(function(source){
          Object.keys(source).forEach(function(item){
            target[item] = source[item]
          })
       })
       return target
     }
     var obj1={
       name:'123'
     }
     var obj2={
       id:100
     }
     var obj3={
       meth(){
         console.log('haha')
       }
     }
     var target=mixins(obj1,[obj2,obj3])
     target.meth()	
```

​		**es6中可使用Object.assign(obj1, obj2, obj3)实现混入。**